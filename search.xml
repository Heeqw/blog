<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode Master Day2</title>
    <url>/blog/2024/07/26/Leetcode-Master-Day2/</url>
    <content><![CDATA[<h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h2><p><strong>题目链接：</strong> <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977.有序数组的平方</a></p>
<blockquote>
<p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序</p>
</blockquote>
<h3 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h3><h4 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h4><p>平方完再排序，时间复杂度为O(nlogn)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            ans[i] = nums[i] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><p>根据示例，对于数组存在负数的情况，平方的非递减排序可能是正数、负数平方交替出现；利用平方的性质，平方后的最大值只可能在数组<strong>两端</strong>出现，因此可以使用双指针法解决；同时我们是先获得了较大的数，因此是倒序赋值；该算法<strong>时间复杂度</strong>为O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[]res = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//对于包含负数的递增数组，平方后的最大值只可能出现在两端</span></span><br><span class="line">            <span class="comment">//因此利用双指针法，倒序赋值并更新左右指针</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] * nums[left] &gt; nums[right] * nums[right])&#123;</span><br><span class="line">                res[i] = nums[left] * nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res[i] = nums[right] * nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小的子数组</a></p>
<blockquote>
<p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p>
<p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>
</blockquote>
<h3 id="题解思路-1"><a href="#题解思路-1" class="headerlink" title="题解思路"></a>题解思路</h3><h4 id="暴力法-1"><a href="#暴力法-1" class="headerlink" title="暴力法"></a>暴力法</h4><p>双层for循环进行嵌套，第一层记录起始位置，第二层遍历找到当前起点情况下最小的满足和为target的终点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= s) &#123;</span><br><span class="line">                    ans = Math.min(ans, j - i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>滑动窗口是双指针法的一种技巧，主要的算法逻辑包含两大部分：<strong>扩大窗口</strong>和 <strong>缩小窗口</strong> ，对<code>left</code> <code>right</code>两个指针，程序先右移<code>right</code>不断扩大窗口直到窗口中的元素满足条件，这时进行缩小处理，左移<code>left</code> 并不断更新最优解，在本题中就是子数组的最小长度；因为遍历的过程两个指针都不会有回退操作，这个算法的时间复杂度为O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//放大窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="comment">//缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                minLength = Math.min(minLength, right - left + <span class="number">1</span>);<span class="comment">//更新最小子数组长度</span></span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> minLength == Integer.MAX_VALUE ? <span class="number">0</span> : minLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">螺旋矩阵</a></p>
<blockquote>
<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
</blockquote>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>螺旋排列操作可以把它视为分层操作，每一层进行上侧从左到右、右侧从上到下、下侧从右到左和左侧从下到上四个操作；每一层操作让剩余矩阵的高度减2，因此分为奇数、偶数两种情况，奇数需要额外处理最中心的矩阵值</p>
<p>代码随想录中强调了<strong>循环不变量原则</strong>，也就是要让操作按照固定规则进行来减少对额外边界条件的判断(误判)</p>
<p><img src="https://i.postimg.cc/HnjMJYnF/image.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 控制循环次数</span></span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 每次循环的开始点(start, start)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 定义填充数字</span></span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop++ &lt; n / <span class="number">2</span>) &#123; <span class="comment">// 判断边界后，loop从1开始</span></span><br><span class="line">            <span class="comment">// 从左到右</span></span><br><span class="line">            <span class="keyword">for</span> (j = start; j &lt; n - loop; j++) &#123;</span><br><span class="line">                res[start][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从上到下</span></span><br><span class="line">            <span class="keyword">for</span> (i = start; i &lt; n - loop; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从右到左</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= loop; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从下到上</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt;= loop; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//奇数特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            res[start][start] = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数组部分的题目主要包括了<strong>二分法</strong>、<strong>双指针法</strong>、<strong>模拟</strong>等主要技巧，双指针法包括快慢指针、左右指针和滑动窗口三种技巧，其中<strong>滑动窗口</strong>是个人需要去着重巩固的部分</p>
]]></content>
      <categories>
        <category>代码随想录</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>代码随想录</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/blog/2024/07/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode Master Day1</title>
    <url>/blog/2024/07/25/Leetcode-Master-Day1/</url>
    <content><![CDATA[<h3 id="数组理论知识"><a href="#数组理论知识" class="headerlink" title="数组理论知识"></a>数组理论知识</h3><blockquote>
<ul>
<li>数组下标都是从0开始的。</li>
<li>数组内存空间的地址是连续的</li>
</ul>
</blockquote>
<h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h3><p><strong>题目链接</strong>：<a href="https://leetcode.cn/problems/binary-search/">704.二分查找</a></p>
<blockquote>
<p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>
</blockquote>
<h4 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h4><p>二分法本质上就是根据比较<code>nums[mid]</code>与<code>target</code>大小来不断缩小边界，可以分[left,right] 和 [left,right)进行具体的代码编写</p>
<h5 id="闭区间解题思路"><a href="#闭区间解题思路" class="headerlink" title="闭区间解题思路"></a>闭区间解题思路</h5><p>闭区间<code>[left,right]</code>时，<code>left == right</code>时区间也成立，因此循环条件为<code>left &lt;= right</code> ;</p>
<p>这里有<code>nums[left] &lt;= nums[mid] &lt;= nums[right];</code> 因此当mid不是目标下标时，边界范围的缩小都取不到mid本身 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 判断nums[mid]与target大小关系缩小区间</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="左闭右开"><a href="#左闭右开" class="headerlink" title="左闭右开"></a>左闭右开</h5><p>此时区间如果成立，则<code>left &lt; right</code> ，这也是循环的条件</p>
<p>这里有<code>nums[left] &lt;= nums[mid] &lt; nums[right];</code>这里对左闭右开区间缩小取值的逻辑需要改变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 判断nums[mid]与target大小关系缩小区间</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">//nums[mid] &lt; target 时左边界值太小，因此需要修改left值，此时`nums[left] &lt;= nums[mid] &lt; target</span></span><br><span class="line">            <span class="comment">//mid一定不是目标值，left = mid + 1;</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//修改右边界值，此时target &lt; nums[mid]&lt; nums[right]，为满足左闭右开区间 right = mid</span></span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h3><p><strong>题目链接</strong>：<a href="https://leetcode.cn/problems/remove-element/description/">27.移除元素</a></p>
<blockquote>
<p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<h4 id="题解思路-1"><a href="#题解思路-1" class="headerlink" title="题解思路"></a>题解思路</h4><h5 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h5><p>双层循环实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val)&#123;</span><br><span class="line">                <span class="comment">//将后续数组全部前移一位</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length; j++)&#123;</span><br><span class="line">                    nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                length--;</span><br><span class="line">                i--;<span class="comment">//注意删去原本的nums[i]后还需要还原再次检查更新后的nums[i]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h5><p>这里的双指针是快慢指针，慢指针在后面，快指针在前面寻找探索，找到不等于<code>val</code> 的值就赋给慢指针并让慢指针前移</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fastIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fastIndex &lt; length)&#123;</span><br><span class="line">            <span class="comment">//找到不等于`val` 的值就赋给慢指针并让慢指针前移</span></span><br><span class="line">            <span class="keyword">if</span> (nums[fastIndex] != val)&#123;</span><br><span class="line">                nums[slowIndex] = nums[fastIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fastIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓展题目"><a href="#拓展题目" class="headerlink" title="拓展题目"></a>拓展题目</h3><h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34.在排序数组中查找元素的第一个和最后一个位置"></a>34.在排序数组中查找元素的第一个和最后一个位置</h4><p><strong>题目链接</strong>：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34.在排序数组中查找元素的第一个和最后一个位置</a></p>
<blockquote>
<p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
</blockquote>
<h5 id="题解思路-2"><a href="#题解思路-2" class="headerlink" title="题解思路"></a>题解思路</h5><p>与最基本的二分法相比，需要修改对<code>nums[mid] == target</code> 的情况，这里分别根据确定左边界还是右边界进行范围的缩小处理；</p>
<p>求左边界时需要尽可能缩小右边界，故<code>right = mid - 1</code> 同理求右边界的情况 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;getLeftBound(nums,target), getRightBound(nums,target)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getLeftBound</span><span class="params">(<span class="type">int</span>[]nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//nums[mid] = target的情况需要收缩右侧边界，赋值与&gt; target一致</span></span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getRightBound</span><span class="params">(<span class="type">int</span>[]nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//nums[mid] = target的情况需要收缩左侧边界，赋值与&lt; target一致</span></span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h4><p><strong>题目链接</strong>：<a href="https://leetcode.cn/problems/search-insert-position/">35.搜索插入位置</a></p>
<blockquote>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>
</blockquote>
<h5 id="题解思路-3"><a href="#题解思路-3" class="headerlink" title="题解思路"></a>题解思路</h5><p>二分法实现，个人比较喜欢闭区间的处理方法，当数组中不存在<code>target</code>时，共有3种情况：数组头，数组中，数组尾；循环的退出条件是<code>left &gt; right</code> 此时循环退出后<code>left = right + 1</code> 考虑数组头的情况时，left &#x3D; 0 ；数组尾情况left &#x3D; length + 1 - 1 都是满足的</p>
<p>因此不存在<code>target</code>时返回的下标就是<code>left</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>代码随想录</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>代码随想录</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-Master-Day3</title>
    <url>/blog/2024/08/05/Leetcode-Master-Day3/</url>
    <content><![CDATA[<h2 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h2><blockquote>
<p>链表是一种通过<strong>指针</strong>串联在一起的线性结构，每一个节点由两部分组成，一个是<strong>数据域</strong>一个是<strong>指针域</strong>（存放指向下一个节点的指针），最后一个节点的指针域指向null。</p>
</blockquote>
<p><em>链表的节点在内存中不是连续分布的</em></p>
<p><strong>链表类型</strong></p>
<ul>
<li>单链表</li>
<li>双链表</li>
<li>循环链表</li>
</ul>
<p><em>双链表定义时指针域包含前后两个方向上的指针</em></p>
<p><strong>链表操作</strong></p>
<p>增删改查——添加节点、删除节点、修改节点、查询节点(按值查询&#x2F;按位查询)</p>
<h4 id="链表v-s-数组"><a href="#链表v-s-数组" class="headerlink" title="链表v.s.数组"></a>链表v.s.数组</h4><p>数组的数据量固定，不便进行增删改变数组大小的操作，更多进行查询操作</p>
<p>链表长度可以动态改变，但是节点分布不连续无法直接得到每个节点的分布位置，适合增删操作多，查询操作少的场景</p>
<h2 id="203-移除元素"><a href="#203-移除元素" class="headerlink" title="203.移除元素"></a>203.移除元素</h2><p><strong>题目链接：</strong> <a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203.移除元素</a></p>
<blockquote>
<p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
</blockquote>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>删除操作就是将节点跳出链表中，将被删除节点<code>node</code>的前一个节点的指针指向<code>node</code>的后一位节点</p>
<p>如果直接对原链表进行操作，需要对头节点进行额外的判断处理，例如<code>head = [1,1,1,1], val = 1</code> 那进行移除元素后链表实际变为空链表，因此需要额外进行判空的处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class="line">    head = head.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 已经为null，提前退出</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种思路就是设定一个空的标兵头节点，这个节点指向原有的链表头，在加上标兵节点的链表中，因为标兵头节点的存在，链表始终非空，可以对链表所有节点统一操作；需注意最后返回时要删去标兵节点也就是返回<code>emptyHead.next</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">emptyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> emptyHead;</span><br><span class="line">		<span class="keyword">while</span> (cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (cur.next.val == val)&#123;</span><br><span class="line">				cur.next = cur.next.next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> emptyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h2><p><strong>题目链接：</strong> <a href="https://leetcode.cn/problems/design-linked-list/description/">707.设计链表</a></p>
<blockquote>
<p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>
<p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针&#x2F;引用。</p>
<p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p>
<p>实现 <code>MyLinkedList</code> 类：</p>
<ul>
<li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li>
<li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li>
<li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li>
<li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li>
<li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li>
<li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li>
</ul>
</blockquote>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>题目中涉及的操作为增删查，这些都需要遍历链表实现，因此需要理清楚<em>下标和实际操作</em>次数的关系；链表的大小是可以动态改变的，为了更好的处理下标合法性的判断，需要为链表增加一个int型<code>size</code>属性记录链表大小</p>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>初始化链表时，链表的大小要初始化为0，为了统一节点的操作，这里额外增加了一个标兵头节点来避免判断链表为空时头节点的情况</p>
<p>因为节点的下标都从0开始，因此删除和查找节点操作的下标应该小于链表的大小；<code>addAtIndex</code> 若是在表尾插入新节点，该节点下标为<code>size - 1 + 1 = size</code> 因此这里的边界判断与删除和查找不同；执行<strong>删除</strong>和<strong>查找</strong>操作改变了链表大小，需要对应的修改<code>size</code> 大小</p>
<p><code>addAtHead</code> 和 <code>addAtTail</code> 也可以用<code>addAtIndex(0)</code>和<code>addAtIndex(size)</code>替代实现 </p>
<p>删除节点和插入节点时，都是去修改指定下标的前一个节点的指针域，插入节点还需要将新建节点指向后面节点；因此在进行节点操作时，遍历到的是下标为<code>index - 1 </code> 的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode()&#123;&#125;</span><br><span class="line">    ListNode (<span class="type">int</span> val)&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode (<span class="type">int</span> val, ListNode node)&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">        ListNode head;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		访问下标为`index`的节点是链表中第`index + 1` 个节点</span></span><br><span class="line"><span class="comment">		因此从标兵头节点开始遍历共`index + 1`步操作</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= size) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index + <span class="number">1</span>; i++)&#123;</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> cur.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//头插法将节点置于标兵节点后方即可</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">            newNode.next = head.next;</span><br><span class="line">            head.next = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//从头节点开始执行size次循环</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val,<span class="literal">null</span>);</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.next = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//执行index次循环到index-1下标节点</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; size) <span class="keyword">return</span>;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val,cur.next);</span><br><span class="line">            cur.next = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//执行index次循环到index-1下标节点</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; size - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">deleteNode</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = deleteNode.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>双链表总体思路与单链表一致，但是需要额外处理<code>prev</code>指针域，定义双链表时类似单链表，增加了<code>tail</code>标兵尾节点；双链表前后两个方向都可以进行访问，在进行遍历时可以选取次数较小的方向进行遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode prev;</span><br><span class="line"></span><br><span class="line">    ListNode()&#123;&#125;</span><br><span class="line">    ListNode (<span class="type">int</span> val)&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode (<span class="type">int</span> val, ListNode node1, ListNode node2)&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = node1;</span><br><span class="line">        <span class="built_in">this</span>.prev = node2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">        ListNode head,tail;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">this</span>.tail = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">            head.next = tail;</span><br><span class="line">            tail.prev = head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= size) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="comment">//判断是哪一边遍历时间更短</span></span><br><span class="line">            <span class="keyword">if</span>(index &gt;= size / <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//tail开始</span></span><br><span class="line">                cur = tail;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; size-index; i++)&#123;</span><br><span class="line">                    cur = cur.prev;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;= index; i++)&#123;</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            addAtIndex(<span class="number">0</span>,val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            addAtIndex(size,val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(index&gt;size)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//index小于0</span></span><br><span class="line">            <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="comment">//找到前驱</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;index; i++)&#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//新建结点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">            newNode.next = pre.next;</span><br><span class="line">            pre.next.prev = newNode;</span><br><span class="line">            newNode.prev = pre;</span><br><span class="line">            pre.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="comment">//判断索引是否有效</span></span><br><span class="line">            <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=size)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//删除操作</span></span><br><span class="line">            size--;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;index; i++)&#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next.next.prev = pre;</span><br><span class="line">            pre.next = pre.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="206-翻转链表"><a href="#206-翻转链表" class="headerlink" title="206.翻转链表"></a>206.翻转链表</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/reverse-linked-list/description/">翻转链表</a></p>
<blockquote>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
</blockquote>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><p>使用两个指针<code>prev</code> 和 <code>current</code> 来遍历链表并改变指针指向</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">		<span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> current.next; <span class="comment">// 保存下一个节点的引用</span></span><br><span class="line">			current.next = prev; <span class="comment">// 反转操作</span></span><br><span class="line">			prev = current; <span class="comment">// 更新prev</span></span><br><span class="line">			current = next; <span class="comment">// 更新current</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> prev; <span class="comment">// 返回新链表的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><p>额外增加一个标兵头节点，遍历链表的同时不断进行头插操作实现反转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseList1</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建标兵头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">empty</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    empty.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 遍历所有节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        <span class="comment">// 头插法</span></span><br><span class="line">        cur.next = empty.next;</span><br><span class="line">        empty.next = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> empty.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>代码随想录</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>代码随想录</tag>
      </tags>
  </entry>
  <entry>
    <title>[MIT6.S081] Lab: Xv6 and Unix utilities</title>
    <url>/blog/2024/08/13/MIT6-S081-Lab-Xv6-and-Unix-utilities/</url>
    <content><![CDATA[<p>实验访问链接：<br><a href="https://pdos.csail.mit.edu/6.828/2020/labs/util.html">MIT 2020</a></p>
<h2 id="Boot-Xv6"><a href="#Boot-Xv6" class="headerlink" title="Boot Xv6"></a>Boot Xv6</h2><p><strong>实验环境配置:</strong> WSL2 + Ubuntu20.04<br>环境配置主要参考<a href="https://pdos.csail.mit.edu/6.828/2020/tools.html">课程网页</a>下载配置，我在配置过程中也遇到了 <code>qemu-system-misc</code> 版本的问题，参考下方命令完成，同时命令中的版本只在Ubuntu20.04版本中存在，因此比较建议使用Ubuntu20.04版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt-get remove qemu-system-misc</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt-get install qemu-system-misc=1:4.2-3ubuntu6</span></span><br></pre></td></tr></table></figure>
<h2 id="Unix-utilities"><a href="#Unix-utilities" class="headerlink" title="Unix utilities"></a>Unix utilities</h2><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>直接调用提供的 <code>sleep</code> 系统调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: sleep &lt;ticks&gt;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tm = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (tm &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;sleep: ticks must be non-negative\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(tm);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h3><p><code>fork()</code> 创建一个子进程，<code>pipe</code> 创建两个管道用于实现父子进程间的通信，分别用于父进程向子进程发送消息和子进程向父进程发送消息<br>通信过程依据<code>fork</code> 返回值是否为0区分父子进程，父进程向管道写入”ping”后调用<code>wait(0)</code> 等待子进程执行完毕后再打印从子进程接收到的信息，实现完整的通信<br><img src="https://i.postimg.cc/jdPBsYvL/pingpong.png" alt="alt text"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    int pipe(int*);</span></span><br><span class="line"><span class="comment">    int read(int, void*, int);</span></span><br><span class="line"><span class="comment">    int fork(void);</span></span><br><span class="line"><span class="comment">    int getpid(void);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    p[0]—— fd pipe read from</span></span><br><span class="line"><span class="comment">    p[1]—— fd pipe write to</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ptoc_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ctop_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: pingpong&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pipe</span>(ptoc_fd);</span><br><span class="line">    <span class="built_in">pipe</span>(ctop_fd);</span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// child process</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">read</span>(ptoc_fd[<span class="number">0</span>], buf, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>, <span class="built_in">getpid</span>(), buf);</span><br><span class="line">        <span class="built_in">write</span>(ctop_fd[<span class="number">1</span>], <span class="string">&quot;pong&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;pong&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">write</span>(ptoc_fd[<span class="number">1</span>], <span class="string">&quot;ping&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;ping&quot;</span>));</span><br><span class="line">        <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">read</span>(ctop_fd[<span class="number">0</span>], buf, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>, <span class="built_in">getpid</span>(), buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h3><h4 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h4><p><strong>基本思想：</strong> 每个合数都可以被一个比它小的素数整除<br><strong>筛选过程：</strong><br>每个进程读取左侧管道的第一个数字n作为当前进程的素数筛，n的倍数会被排除，未被整除的数字传递至下一个进程，不断循环重复<br><strong>管道实现特点：</strong></p>
<ul>
<li>每个素数由一个单独的进程处理。</li>
<li>每个进程只负责过滤一个素数的倍数。</li>
<li>数据通过管道从一个进程流向下一个进程<br><img src="https://i.postimg.cc/8k2zXK8Y/sieve.gif" alt="alt text"></li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p><code>child</code> 函数接收一个指向左侧管道的指针pl，每次尝试从左侧管道读取一个数，若成功读取则fork子进程递归调用 <code>child</code> 函数，使用新创建的右侧管道，同时父进程传递经过筛选的不可被当前素数整除的数至右侧管道<br><code>main</code> 函数通过循环获取2-35范围内的素数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIME_NUM 35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READEND 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITEEND 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">child</span><span class="params">(<span class="type">int</span>* pl)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">	<span class="built_in">pipe</span>(p);</span><br><span class="line">	<span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">child</span>(p);	</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">close</span>(p[READEND]);</span><br><span class="line">		<span class="comment">// feed the int array</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;PRIME_NUM<span class="number">+1</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">write</span>(p[WRITEEND], &amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(p[WRITEEND]);</span><br><span class="line">		<span class="built_in">wait</span>((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">child</span><span class="params">(<span class="type">int</span>* pl)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> pr[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(pl[WRITEEND]);</span><br><span class="line">	<span class="comment">// tries to read the first number</span></span><br><span class="line">	<span class="type">int</span> read_result = <span class="built_in">read</span>(pl[READEND], &amp;n, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">if</span> (read_result == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">// right side pipe</span></span><br><span class="line">	<span class="built_in">pipe</span>(pr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">child</span>(pr);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">close</span>(pr[READEND]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, n);</span><br><span class="line">		<span class="type">int</span> prime = n;</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">read</span>(pl[READEND], &amp;n, <span class="built_in">sizeof</span>(<span class="type">int</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (n%prime != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">write</span>(pr[WRITEEND], &amp;n, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(pr[WRITEEND]);</span><br><span class="line">		<span class="built_in">wait</span>((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>用递归方式找到指定的文件夹下符合某个名字的文件，主要参考<code>ls.c</code> 代码</p>
<ul>
<li>若当前路径为文件名，直接判断文件名与目标文件名是否一致</li>
<li>若为目录，则递归调用，遍历文件夹下所有文件进行比较<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *target)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">dirent</span> de;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((fd = <span class="built_in">open</span>(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fstat</span>(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">		<span class="built_in">close</span>(fd);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">	<span class="keyword">case</span> T_FILE:</span><br><span class="line">		<span class="comment">// 如果文件名结尾匹配 `/target`，则视为匹配</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>(path+<span class="built_in">strlen</span>(path)-<span class="built_in">strlen</span>(target), target) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> T_DIR:</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">		p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">		*p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">read</span>(fd, &amp;de, <span class="built_in">sizeof</span>(de)) == <span class="built_in">sizeof</span>(de))&#123;</span><br><span class="line">			<span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">memmove</span>(p, de.name, DIRSIZ);</span><br><span class="line">			p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">stat</span>(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 不要进入 `.` 和 `..`</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf+<span class="built_in">strlen</span>(buf)<span class="number">-2</span>, <span class="string">&quot;/.&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(buf+<span class="built_in">strlen</span>(buf)<span class="number">-3</span>, <span class="string">&quot;/..&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">find</span>(buf, target); <span class="comment">// 递归查找</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> target[<span class="number">512</span>];</span><br><span class="line">	target[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>; <span class="comment">// 为查找的文件名添加 / 在开头</span></span><br><span class="line">	<span class="built_in">strcpy</span>(target<span class="number">+1</span>, argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">find</span>(argv[<span class="number">1</span>], target);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><p><code>readline</code> 函数从标准输入读取一行数据，并将其解析为参数。</p>
<ul>
<li>逐字符读取输入，直到遇到换行符或达到缓冲区限制。</li>
<li>将输入解析为参数，以空格为分隔符。</li>
<li>返回更新后的参数数量。</li>
</ul>
<p><code>main</code> 函数实现了 xargs 的核心逻辑：</p>
<p>a. 参数检查：</p>
<ul>
<li>确保至少提供了一个命令作为参数。</li>
</ul>
<p>b. 初始化：</p>
<ul>
<li>复制命令名称和初始参数。</li>
</ul>
<p>c. 主循环：</p>
<ul>
<li>重复调用 <code>readline</code> 函数来获取新的参数。</li>
<li>对于每一行输入：<ul>
<li>创建一个子进程（使用 <code>fork()</code>）。</li>
<li>在子进程中执行命令（使用 <code>exec()</code>）。</li>
<li>父进程等待子进程完成（使用 <code>wait()</code>）。</li>
</ul>
</li>
</ul>
<p>工作流程：</p>
<ul>
<li>程序从命令行获取初始命令和参数。</li>
<li>然后，它从标准输入读取额外的参数（每行一组）。</li>
<li>对于每一行输入，它会执行一次指定的命令，将该行的内容作为额外的参数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">readline</span><span class="params">(<span class="type">char</span> *new_argv[<span class="number">32</span>], <span class="type">int</span> curr_argc)</span></span>&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">read</span>(<span class="number">0</span>, buf+n, <span class="number">1</span>))&#123;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1023</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;argument is too long\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (buf[n] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		n++;</span><br><span class="line">	&#125;</span><br><span class="line">	buf[n] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(offset &lt; n)&#123;</span><br><span class="line">		new_argv[curr_argc++] = buf + offset;</span><br><span class="line">		<span class="keyword">while</span>(buf[offset] != <span class="string">&#x27; &#x27;</span> &amp;&amp; offset &lt; n)&#123;</span><br><span class="line">			offset++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(buf[offset] == <span class="string">&#x27; &#x27;</span> &amp;&amp; offset &lt; n)&#123;</span><br><span class="line">			buf[offset++] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> curr_argc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: xargs command (arg ...)\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> *command = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + <span class="number">1</span>);</span><br><span class="line">	<span class="type">char</span> *new_argv[MAXARG];</span><br><span class="line">	<span class="built_in">strcpy</span>(command, argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		new_argv[i - <span class="number">1</span>] = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(argv[i]) + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(new_argv[i - <span class="number">1</span>], argv[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> curr_argc;</span><br><span class="line">	<span class="keyword">while</span>((curr_argc = <span class="built_in">readline</span>(new_argv, argc - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		new_argv[curr_argc] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">exec</span>(command, new_argv);</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;exec failed\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MIT6.S081</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>xv6</tag>
        <tag>MIT6.S081</tag>
      </tags>
  </entry>
</search>
